<!DOCTYPE html>
<html lang="pt-BR">
<head>
    10.73 12 10.73C12.66 10.73 13.29 10.62 13.88 10.4C14.47 10.18 15.02 9.88 15.5 9.5V11.5ZM12 8.5C10.62 8.5 9.5 7.38 9.5 6C9.5 4.62 10.62 3.5 12 3.5C13.38 3.5 14.5 4.62 14.5 6C14.5 7.38 13.38 8.5 12 8.5Z" fill="white"/> </svg> </div>
        <h1>Otimização Topológica de Redes Elétricas</h1>
        <p>Ferramenta para encontrar a melhor topologia de rede radial (MST) usando AG, considerando custo de chaves vs. atendimento de carga.</p>
    </div>

    <div class="main-grid">
            <div class="card">
                <h2>Parâmetros da Rede</h2>
                <div class="row"> <div> <label for="numBarras">Nº de Barras</label> <input id="numBarras" type="number" min="2" value="10" class="mono" /> </div> <div> <label for="sbase">Sbase (MVA)</label> <input id="sbase" type="number" class="mono" value="10" step="0.1" min="0.1"/> </div> <div> <label for="vbase">Vbase (kV LL)</label> <input id="vbase" type="number" class="mono" value="13.8" step="0.1" min="0.1"/> </div> </div>
                <h3>Limites Operacionais</h3> <div class="row"> <div> 
<label for="vmin">Tensão Mínima (pu)</label> <input id="vmin" type="number" class="mono" value="0.95" step="0.01" min="0"/> </div> <div> <label for="vmax">Tensão Máxima (pu)</label> <input id="vmax" type="number" class="mono" value="1.05" step="0.01" min="0"/> </div> </div>
            </div>
                        <div class="card" style="margin-top: 20px;">
                <h2>Dados da Rede</h2>
                <div class="row" style="margin-bottom: 20px; justify-content: space-between;"> 
                    <button class="btn secondary" id="btnGerar">Atualizar Barras/Cargas</button> 
                    <button class="btn secondary" id="btnAddBarra">+ Add Barra</button> 
                    <button class="btn primary" id="btnExemplo10">Carregar Exemplo 10 Barras</button> 
                </div>
    
            <h3>Malha da Rede (Sistema Base)</h3> <button class="btn primary" id="btnAddLinha" style="margin-bottom:12px">+ Add Linha</button> <div class="table-scroll"> <table id="tblMalha"> <thead><tr><th>#</th><th>De</th><th>Para</th><th>R (ohm)</th><th>X (ohm)</th><th>Smax (MVA)</th><th>Ações</th></tr></thead> <tbody></tbody> </table> </div>
                <h3>Cargas nas Barras</h3> 
                <div class="table-scroll"> 
                    <table id="tblCargas"> 
                 <thead>
                            </thead> 
                        <tbody></tbody> 
                    </table> 
        </div>
            </div>
        </div>
        <div>
            <div class="card ga-card">
                <h2> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: -5px; margin-right: 5px; color: var(--utfpr-blue-light);"><path d="M12.22 2h-4.44a2 2 0 0 0-2 2v.77a2 2 0 0 0 .59 1.42l4.44 4.44a2 2 0 0 1 .59 1.42v4.44a2 2 0 0 0 2 2h.77a2 2 0 0 0 1.42-.59l4.44-4.44a2 2 0 0 1 1.42-.59h4.44a2 2 0 0 0 2-2v-4.44a2 2 0 0 0-2-2h-4.44a2 2 0 0 1-1.42-.59L13.64 2.59A2 2 0 0 0 12.22 2z"></path><path d="M18.5 2.5 21.5 5.5"></path><path d="m2 2 3 3"></path><path d="M12 12 8 8"></path></svg> Zona de Otimização (GA) </h2>
                <h3>1. Defina a(s) Contingência(s)</h3> <div class="row"> <div style="flex-grow:1"> 
<label for="linhaFalha">Linha(s) em Falha (Ctrl+Click)</label> <select id="linhaFalha" class="mono" multiple size="5"></select> </div> </div>
                
                <h3>2. Parâmetros do GA</h3>
                
                <div class="row"> <div style="flex-grow:1">
                    <label for="substationBuses">Barras das Subestações (Fontes)</label>
                    <input id="substationBuses" type="text" class="mono" value="1" placeholder="Ex: 1,20,30" />
                </div> </div>
                <div class="ga-params-grid"> <div> <label for="gaPopSize">População</label> <input id="gaPopSize" type="number" class="mono" value="100" step="10" min="10"/> </div> <div> <label for="gaMaxGen">Gerações</label> <input id="gaMaxGen" type="number" class="mono" value="100" step="10" min="10"/> </div> <div> <label for="gaMutationRate">Mutação (%)</label> <input id="gaMutationRate" type="number" class="mono" value="15" min="0" max="100" step="1"/> </div> <div> <label for="gaPesoChave">Peso Custo Linha Base</label> <input id="gaPesoChave" type="number" class="mono" value="0.5" min="0" step="0.05" /> </div> </div>
 
               
                <h3>3. Parâmetros de Expansão (Linhas NA)</h3> 
                                <div class="ga-params-grid"> <div> <label for="gaCustoNA">Custo Linha NA</label> <input id="gaCustoNA" type="number" class="mono" value="10.0" min="0" step="0.1"/> </div> <div> <label for="gaMaxNA">Nº Máx. Linhas NA</label> <input id="gaMaxNA" type="number" class="mono" value="3" min="0" step="1"/> </div> <div> <label for="gaR_NA">R Padrão (ohm/km)</label> <input id="gaR_NA" type="number" class="mono" value="0.1" step="0.01" min="0"/> </div> <div> <label for="gaX_NA">X Padrão (ohm/km)</label> <input id="gaX_NA" type="number" class="mono" value="0.2" step="0.01" min="0"/> </div> <div> <label for="gaSmax_NA">Smax Padrão (MVA)</label> <input id="gaSmax_NA" type="number" class="mono" value="5.0" step="0.1" min="0.1"/> </div> </div>

                <h3>4. Execução</h3> 
                class="progress-bar-container"><div id="ga-progress-bar"></div></div> <div class="ga-stats"> <div class="stat-item"> <label>Melhor Fitness</label> <div class="value mono" id="best-fitness-display">---</div> </div> <div class="stat-item"> <label>Carga Não Atendida</label> <div class="value mono" id="unserved-load-display">--- MW</div> </div> <div class="stat-item"> <label>Perdas Totais</label> <div class="value mono" id="losses-display">--- MW</div> </div> <div class="stat-item"> <label>Chaves Ativas (NA)</label> <div class="value mono" id="active-switches-display">-- (--)</div> </div> <div class="stat-item" style="grid-column: 1 / -1;"> <label>Custo Chaves (Fit)</label> <div class="value mono" id="switch-cost-display">---</div> </div> </div> <div id="ga-log-detail" class="mono">Log...</div> </div>
            </div>
        </div>
        <div class="card grid-span-all">
       
             <h2>Resultados</h2> <div class="svg-wrap" id="svgWrap"> <svg id="svg" width="100%" height="100%" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet"> <defs> <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head" /></marker> <marker id="arrowhead-overload" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head overload" /></marker> <marker id="arrowhead-new" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="newly-added-arrow-head" /></marker> </defs> </svg> </div>
            <div class="legend"> <span class="pill"><small>V barra:</small> |V|
pu e Âng(°)</span> <span class="pill"><small>Fluxo:</small> P/Q MW/MVAr</span> <span class="pill" style="background: var(--utfpr-blue-light); border-color:var(--utfpr-blue-light); color:white"><small>Linha Base</small></span> <span class="pill" style="background: var(--highlight-green); border-color:var(--highlight-green); color:white;"><small>Linha Nova/Manobra</small></span> <span class="pill" style="border-style: dashed; border-color: var(--utfpr-blue-light);"><small>Linha NA Padrão</small></span> <span class="pill" style="background: var(--bad); border-color:var(--bad); color:white; font-weight: bold;"><small>Sobrecarga</small></span> </div>
            <div class="divider"></div> <h3>Tensões nas Barras</h3> <div class="table-scroll"> <table id="tblResBarras"> <thead><tr><th>Barra</th><th>|V|
(pu)</th><th>Ângulo (°)</th><th>P carga (MW)</th><th>Q carga (MVAr)</th></tr></thead> <tbody></tbody> </table> </div>
            <h3 style="margin-top: 20px;">Fluxo e Perdas nos Ramos</h3> <div class="table-scroll"> <table id="tblResRamos"> <thead><tr><th>#</th><th>De</th><th>Para</th><th>P (MW)</th><th>Q (MVAr)</th><th>|S|
(MVA)</th><th>Smax (MVA)</th><th>Perdas P (MW)</th></tr></thead> <tbody></tbody> </table> </div>
        </div>
    </div>

    <script>
        // --- Funções Auxiliares (c(), addLinhaRow, etc. - Sem lógica do AG/Fluxo) ---
        function c(re=0,im=0){return{re,im}} function cAdd(a,b){return c(a.re+b.re,a.im+b.im)} function cSub(a,b){return c(a.re-b.re,a.im-b.im)} function cMul(a,b){return c(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re)} function cConj(a){return c(a.re,-a.im)} function cAbs(a){return Math.hypot(a.re,a.im)} function cDiv(a,b){const d=b.re*b.re+b.im*b.im||1e-30;return c((a.re*b.re+a.im*b.im)/d,(a.im*b.re-a.re*b.im)/d)} function pol2rec(m,d){const r=d*Math.PI/180;return c(m*Math.cos(r),m*Math.sin(r))} function angDeg(a){return Math.atan2(a.im,a.re)*180/Math.PI}
        
        const elNb=document.getElementById('numBarras'),elSbase=document.getElementById('sbase'),elVbase=document.getElementById('vbase'),elVmin=document.getElementById('vmin'),elVmax=document.getElementById('vmax'),tblMalha=document.getElementById('tblMalha').querySelector('tbody'),tblCargasTbody=document.getElementById('tblCargas').querySelector('tbody'),tblCargasThead=document.getElementById('tblCargas').querySelector('thead'),btnGerar=document.getElementById('btnGerar'),btnAddBarra=document.getElementById('btnAddBarra'),btnAddLinha=document.getElementById('btnAddLinha'),btnExemplo10=document.getElementById('btnExemplo10'),selLinhaFalha=document.getElementById('linhaFalha'),elGaPopSize=document.getElementById('gaPopSize'),elGaMaxGen=document.getElementById('gaMaxGen'),elGaMutationRate=document.getElementById('gaMutationRate'),elGaPesoChave=document.getElementById('gaPesoChave'),btnFluxo=document.getElementById('btnFluxo'),btnOtimizar=document.getElementById('btnOtimizar'),gaStatus=document.getElementById('ga-status'),gaProgressBar=document.getElementById('ga-progress-bar'),bestFitnessDisplay=document.getElementById('best-fitness-display'),unservedLoadDisplay=document.getElementById('unserved-load-display'),lossesDisplay=document.getElementById('losses-display'),activeSwitchesDisplay=document.getElementById('active-switches-display'),switchCostDisplay=document.getElementById('switch-cost-display'),gaLogDetail=document.getElementById('ga-log-detail'),svgWrap=document.getElementById('svgWrap'),svg=document.getElementById('svg'),tblResBarras=document.getElementById('tblResBarras').querySelector('tbody'),tblResRamos=document.getElementById('tblResRamos').querySelector('tbody');
        
        // *** NOVA CONSTANTE ADICIONADA ***
        const elSubstationBuses = document.getElementById('substationBuses');
        // *** FIM DA ADIÇÃO ***
        
        const elGaCustoNA = document.getElementById('gaCustoNA');
        const elGaMaxNA = document.getElementById('gaMaxNA'); const elGaR_NA = document.getElementById('gaR_NA');
        const elGaX_NA = document.getElementById('gaX_NA');
        const elGaSmax_NA = document.getElementById('gaSmax_NA');

        let cargas={}; let baseMstLineKeys = new Set();
        function getNb(){const n=parseInt(elNb.value,10);return isFinite(n)&&n>=2?n:2} function logGADetail(m,t=''){const s=document.createElement('div');s.textContent=`[${new Date().toLocaleTimeString()}] ${m}`;if(t)s.className=`log-${t}`;gaLogDetail.appendChild(s);gaLogDetail.scrollTop=gaLogDetail.scrollHeight}
        
        // --- MUDANÇA: Lógica de Cargas e Barras (Leitura das fontes) ---
        function getSubstationBuses() {
            const nb = getNb();
            const sBusesInput = elSubstationBuses.value;
            const substationBuses = sBusesInput.split(',').map(Number).filter(n => n >= 1 && n <= nb);
            if (substationBuses.length === 0) {
                 substationBuses.push(1); // Garante pelo menos a fonte 1
                 elSubstationBuses.value = "1";
            }
            return substationBuses;
        }

        function gerarTabelaCargas(){
            const n=getNb(),oC={...cargas};
            cargas={};
            tblCargasTbody.innerHTML=''; 
            tblCargasThead.innerHTML = '<tr><th>Barra</th><th>P (MW)</th><th>Q (MVAr)</th><th>Coord. X</th><th>Coord. Y</th><th>Ações</th></tr>';

            const substationBuses = getSubstationBuses(); // Pega as fontes
            
            for(let b=1; b<=n; b++) {
                const isSlack = substationBuses.includes(b);
                const r=document.createElement('tr'), tB=document.createElement('td');
                tB.textContent = `${b}${isSlack ? ' (Fonte)' : ''}`;
                
                const tP=document.createElement('td'),tQ=document.createElement('td');
                const tX=document.createElement('td'),tY=document.createElement('td');
                const tA=document.createElement('td');
                
                let iP, iQ, iX, iY, bD;

                if (isSlack) {
                    tP.textContent = '---';
                    tQ.textContent = '---';
                    iX=document.createElement('input'); iX.type='number'; iX.value=oC[b]?.X??(b*10-10); iX.className='mono';
                    iY=document.createElement('input'); iY.type='number'; iY.value=oC[b]?.Y??(b*5); iY.className='mono';
                    tA.textContent = '---'; // Não pode remover fonte
                } else {
                    iP=document.createElement('input');iP.type='number';iP.step='0.001';iP.value=oC[b]?.P??0;iP.className='mono';iP.min="0";
                    iQ=document.createElement('input');iQ.type='number';iQ.step='0.001';iQ.value=oC[b]?.Q??0;iQ.className='mono';
                    iX=document.createElement('input'); iX.type='number'; iX.value=oC[b]?.X??(b*10); iX.className='mono';
                    iY=document.createElement('input'); iY.type='number'; iY.value=oC[b]?.Y??(b*5); iY.className='mono';
                    
                    bD=document.createElement('button'); bD.textContent='Remover'; bD.className='btn secondary';
                    bD.style.cssText = 'background-color: var(--bad); color: white; border-color: #a12b37; padding: 8px 12px; font-size: 12px;';
                    
                    ((barraAtual) => {
                        bD.addEventListener('click', (e) => { 
                            e.preventDefault(); 
                            if(confirm(`Tem certeza que deseja remover a Barra ${barraAtual}? Isso removerá também todas as linhas conectadas a ela.`)) {
                                removerBarra(barraAtual); 
                            }
                        });
                    })(b);
                    tA.appendChild(bD);
                }
                
                const updateCarga = () => {
                     cargas[b]={
                         P: (isSlack ? 0 : parseFloat(iP.value||0)),
                         Q: (isSlack ? 0 : parseFloat(iQ.value||0)),
                         X: parseFloat(iX.value||0),
                         Y: parseFloat(iY.value||0)
                     }
                };
                
                if (iP) iP.addEventListener('input', updateCarga);
                if (iQ) iQ.addEventListener('input', updateCarga);
                iX.addEventListener('input', updateCarga);
                iY.addEventListener('input', updateCarga);

                if (iP) tP.appendChild(iP);
                if (iQ) tQ.appendChild(iQ);
                tX.appendChild(iX);tY.appendChild(iY);
                r.appendChild(tB);r.appendChild(tP);r.appendChild(tQ);r.appendChild(tX);r.appendChild(tY);r.appendChild(tA);
                tblCargasTbody.appendChild(r);
                
                cargas[b]={
                    P: (isSlack ? 0 : parseFloat(iP?.value||0)),
                    Q: (isSlack ? 0 : parseFloat(iQ?.value||0)),
                    X: parseFloat(iX.value||0),
                    Y: parseFloat(iY.value||0)
                };
            }
            atualizarSelectsLinhas();
        }

        function removerBarra(barraNumero) {
            const substationBuses = getSubstationBuses();
            if (substationBuses.includes(barraNumero)) {
                alert("Não é possível remover uma Barra de Subestação (Fonte).");
                return;
            }
            // ... (resto da função removerBarra [cite: 108-126] idêntico) ...
const nbAntigo = getNb();
if (barraNumero > nbAntigo) return;

            const nbNovo = nbAntigo - 1;
            elNb.value = nbNovo;
const newCargas = {};
// Mantém as fontes e re-indexa
            let idxNovo = 1;
            const newSlackMap = {}; // Mapeia antigo -> novo
            
            // 1. Recria as fontes
            substationBuses.forEach(sBus => {
                if (sBus < barraNumero) {
                    newCargas[sBus] = cargas[sBus];
                    newSlackMap[sBus] = sBus;
                } else if (sBus > barraNumero) {
                    const newIdx = sBus - 1;
                    newCargas[newIdx] = cargas[sBus];
                    newSlackMap[sBus] = newIdx;
                }
                // Se sBus === barraNumero, ela é pulada (mas já foi bloqueada acima)
            });
            
            // 2. Recria as cargas
            idxNovo = 1;
            for (let b = 1; b <= nbAntigo; b++) {
                if (substationBuses.includes(b)) continue; // Já processado
                if (b === barraNumero) continue; // Pula a removida
                
                while(newCargas[idxNovo]) idxNovo++; // Acha o próximo slot livre
                
                let newIdx = (b > barraNumero) ? b - 1 : b;
                if (newCargas[newIdx]) newIdx = idxNovo; // Ajusta se o slot já foi pego por uma fonte
                
                newCargas[newIdx] = cargas[b];
            }
            
            // Atualiza a string de subestações
            elSubstationBuses.value = substationBuses.map(sBus => newSlackMap[sBus]).filter(Boolean).join(',');

// 3. Re-indexar 'tblMalha'
            let linhas = getLinhasFromTable(tblMalha);
const newLinhas = [];
            for (const l of linhas) {
                if (l.de === barraNumero || l.para === barraNumero) {
                    continue;
                }
let newDe = (l.de > barraNumero) ? l.de - 1 : l.de;
let newPara = (l.para > barraNumero) ? l.para - 1 : l.para;
if (newDe !== newPara) {
                    newLinhas.push({ ...l, de: String(newDe), para: String(newPara) });
}
            }
            
            cargas = newCargas;
gerarTabelaCargas();
tblMalha.innerHTML = '';
newLinhas.forEach(l => addLinhaRow(tblMalha, l));
atualizarSelectsLinhas();
        }
        // --- FIM MUDANÇA ---
        
        // ... (funções addLinhaRow, renumerarLinhas, atualizarSelectsLinhas, updateLinhaFalhaSelect, getLinhasFromTable ... idênticas) ...

        // ... (função carregarExemplo10 [cite: 133-145] ... idêntica, mas atualize as fontes) ...
        function carregarExemplo10(){
            tblMalha.innerHTML='';
elNb.value=10;
            // *** MUDANÇA ***
            elSubstationBuses.value = "1"; // Exemplo 10 só tem uma fonte
            // *** FIM MUDANÇA ***
            gerarTabelaCargas();
            
            // ... (resto da função [cite: 133-145] idêntico) ...
}
        
        // ... (função renderResultados [cite: 145-151] idêntica) ...
        // ... (função desenharRede [cite: 151-197] idêntica) ...
        // ... (função setupSvgPanning [cite: 197-211] idêntica) ...
        // ... (Funções do AG (Seleção, Crossover, Mutação) [cite: 211-231] idênticas) ...
        // ... (Gerenciamento do Web Worker [cite: 231-255] idêntico) ...
        
        // --- MUDANÇA: runGA (Passa as fontes para o worker) ---
async function runGA() {
            // ... (limpeza de UI [cite: 256-257] idêntica) ...
btnOtimizar.disabled = true; btnFluxo.disabled = true;
            const nb = getNb();
const linhaFalhaKeys = Array.from(selLinhaFalha.selectedOptions).map(opt => opt.value).filter(val => val !== 'SEM_FALHA');
            
            // *** ADIÇÃO: LER FONTES ***
            const substationBuses = getSubstationBuses();
            logGADetail(`Fontes (Subestações): ${substationBuses.join(', ')}`);
            // *** FIM ADIÇÃO ***
            
const custoBase = parseFloat(elGaPesoChave.value);
            const custoNA = parseFloat(elGaCustoNA.value);
            const maxNALinhas = parseInt(elGaMaxNA.value, 10);
            
            // ... (código de montagem 'allLines' [cite: 260-273] idêntico) ...
            
logGADetail(`Custo Base: ${custoBase}, Custo NA: ${custoNA}, Limite NA: ${maxNALinhas}`);

            const staticData = {
                allLines: allLines,
                linhaFalhaKeys: linhaFalhaKeys,
                nb: nb,
                vMin: parseFloat(elVmin.value),
                vMax: parseFloat(elVmax.value),
maxNALinhas: maxNALinhas,
                // *** ADIÇÃO ***
                substationBuses: substationBuses,
                // *** FIM ADIÇÃO ***
                cargas: JSON.parse(JSON.stringify(cargas)),
                Sbase: parseFloat(elSbase.value),
                Vbase_kV: parseFloat(elVbase.value)
            };
            
            // ... (Restante de runGA [cite: 282-321] idêntico) ...
}

        // --- Eventos ---
        btnGerar.addEventListener('click', gerarTabelaCargas);
        // ... (outros eventos [cite: 322-323]) ...
        btnExemplo10.addEventListener('click', carregarExemplo10); 
        btnOtimizar.addEventListener('click', runGA);

        // *** CÓPIA LOCAL de DSU, validarRadial e runFluxo (MODIFICADOS) ***
        
        // --- MUDANÇA: validarRadialLocal aceita slackBusId ---
function validarRadialLocal(n, l, slackBusId = 1){
            if(l.length===0){const u=new Set();for(let b=1;b<=n;b++) if(b !== slackBusId) u.add(b);return{ok:n<=1,msg:n<=1?'OK':'Não conectado (sem linhas)',unservedBuses:u}} const adj=Array(n+1).fill(0).map(()=>[]);let hasLoopOrMultiParent = false;
const q=[slackBusId],visited=new Set([slackBusId]),parent={}; let head = 0; for(const e of l){ if(!e || typeof e.de !== 'number' || typeof e.para !== 'number' || e.de < 1 || e.de > n || e.para < 1 || e.para > n) { console.warn("Linha inválida em validarRadialLocal:", e);
continue; } if(e.para===slackBusId)return{ok:!1,msg:`Fonte (Barra ${slackBusId}) não pode ter entrada`,unservedBuses:new Set()}; adj[e.de].push(e.para); } while(head < q.length){ const u=q[head++];
for(const v of adj[u]){ if(!v || v < 1 || v > n) { console.warn("Índice v inválido em validarRadialLocal:", v, "vindo de u:", u);
continue; } if(visited.has(v)){ hasLoopOrMultiParent = true; break; } visited.add(v); parent[v]=u; q.push(v);
} if(hasLoopOrMultiParent) break;} if(hasLoopOrMultiParent) return {ok:false, msg:'Loop ou barra multi-alimentada detectado.', unservedBuses: new Set()}; const connectedCount=visited.size, uB=new Set(); for(let b=1;b<=n;b++)if(!visited.has(b))uB.add(b);
if(connectedCount<n)return{ok:!0,msg:`Parcialmente conectado. ${uB.size} isoladas.`,unservedBuses:uB}; return{ok:!0,msg:'Rede OK',unservedBuses:uB}}
        
        // --- MUDANÇA: runFluxoLocal aceita slackBusId ---
async function runFluxoLocal(linhasData, slackBusId = 1) {
            const nb = getNb();
const Sbase = parseFloat(elSbase.value); const Vbase_kV = parseFloat(elVbase.value); const tol = 1e-6; const iterMax = 100; let perdasMWtotal = 0;
const orientedLinhas = []; const adj = Array(nb + 1).fill(0).map(() => []);
            if (!Array.isArray(linhasData)) { const rBE = [];
for(let b=1; b<=nb; b++) rBE.push({barra:b, Vmag:(b===slackBusId?1:0), Vang:0, Pmw:(cargas[b]?.P||0), Qmvar:(cargas[b]?.Q||0), isConnected:(b===slackBusId)}); const uE = new Set();
for(let b=1; b<=nb; b++) if(b !== slackBusId && cargas[b] && (cargas[b].P > 0 || cargas[b].Q > 0)) uE.add(b);
return { resBarras: rBE, resRamos: [], perdasMWtotal: 0, unservedBuses: uE };
}
            const validLinhasData = linhasData.filter(l => l && typeof l.de === 'number' && typeof l.para === 'number' && l.de >= 1 && l.de <= nb && l.para >= 1 && l.para <= nb);
if (validLinhasData.length === 0 && nb > 1) { const rBE = [];
for(let b=1; b<=nb; b++) rBE.push({barra:b, Vmag:(b===slackBusId?1:0), Vang:0, Pmw:(cargas[b]?.P||0), Qmvar:(cargas[b]?.Q||0), isConnected:(b===slackBusId)}); const uE = new Set();
for(let b=1; b<=nb; b++) if(b !== slackBusId && cargas[b] && (cargas[b].P > 0 || cargas[b].Q > 0)) uE.add(b);
return { resBarras: rBE, resRamos: [], perdasMWtotal: 0, unservedBuses: uE };
}
            validLinhasData.forEach(l => { adj[l.de].push(l.para); adj[l.para].push(l.de); });
const parent = Array(nb + 1).fill(0); const q = [slackBusId]; const visited = Array(nb + 1).fill(false); visited[slackBusId] = true;
const connectedBuses = new Set([slackBusId]); let head = 0;
            while(head < q.length) { const u = q[head++];
for (const v of adj[u]) { if (v >= 1 && v <= nb && !visited[v]) { visited[v] = true;
parent[v] = u; connectedBuses.add(v); q.push(v); const l = validLinhasData.find(line => (line.de === u && line.para === v) || (line.de === v && line.para === u));
if (l) orientedLinhas.push({ ...l, de: u, para: v }); } } }
            
            // *** MUDANÇA: Passa o slackBusId ***
            const validationResult = validarRadialLocal(nb, orientedLinhas, slackBusId);
if (!validationResult.ok && !validationResult.msg.includes('Parcialmente conectado') && !validationResult.msg.includes('Não conectado')) { console.error("runFluxoLocal: Validação crítica falhou:", validationResult.msg);
throw new Error('Falha validação local (erro crítico): ' + validationResult.msg);
}
            const unservedBusesFromValidation = validationResult.unservedBuses;
const Zbase = (Vbase_kV * Vbase_kV) / Sbase; const V = Array(nb + 1).fill(0).map(() => c(1, 0)); // V inicial é 1 pu
const S = Array(nb + 1).fill(0).map(() => c(0, 0));
            
            // *** MUDANÇA: Loop ignora o slackBusId atual ***
            for (let b = 1; b <= nb; b++) {
                if (b === slackBusId) continue; // Fontes não são cargas
                if (connectedBuses.has(b) && cargas[b]) S[b] = c(parseFloat(cargas[b].P || 0) / Sbase, parseFloat(cargas[b].Q || 0) / Sbase);
else S[b] = c(0, 0); }
            
             if (orientedLinhas.length === 0 && nb > 1) { const rBE=[];
for (let b=1; b<=nb; b++) rBE.push({ barra:b, Vmag:(b===slackBusId ? 1:0), Vang:0, Pmw:(cargas[b]?.P||0), Qmvar:(cargas[b]?.Q||0), isConnected:(b===slackBusId) }); const uBE=new Set(unservedBusesFromValidation);
for(let b=1; b<=nb; b++) if(b !== slackBusId && !connectedBuses.has(b) && cargas[b] && (cargas[b].P > 0 || cargas[b].Q > 0)) uBE.add(b);
return { resBarras:rBE, resRamos:[], perdasMWtotal:0, unservedBuses:uBE }; }
            
const ramos = orientedLinhas.map((e) => { const R = typeof e.R ==='number'&&isFinite(e.R)?e.R:0; const X = typeof e.X ==='number'&&isFinite(e.X)?e.X:0; const Zr = Zbase > 1e-9 ? R / Zbase : 0; const Zi = Zbase > 1e-9 ? X / Zbase : 0; return { idx:e.id, de:e.de, para:e.para, Z:c(Zr, Zi), Smax:e.Smax, isNA:e.isNA }; });
const adjFilhos = Array(nb + 1).fill(0).map(() => []); ramos.forEach(r => adjFilhos[r.de].push(r.para)); const depth = Array(nb + 1).fill(0);
const orderFwd = []; const orderBwd = []; { const qFwd = [slackBusId]; depth[slackBusId] = 0;
const visitedOrder = new Set([slackBusId]); let headFwd = 0; while (headFwd < qFwd.length) { const u = qFwd[headFwd++]; orderFwd.push(u);
adjFilhos[u].forEach(v => { if (v >= 1 && v <= nb && !visitedOrder.has(v)) { depth[v] = depth[u] + 1; qFwd.push(v); visitedOrder.add(v); } });
} const nodes = []; visitedOrder.forEach(b => { if (b !== slackBusId) nodes.push(b); }); nodes.sort((a, b) => depth[b] - depth[a]);
orderBwd.push(...nodes); } const ramoIdx = {}; ramos.forEach(r => { ramoIdx[`${r.de}-${r.para}`] = r; }); let conv = false;
let V_ant = V.map(v => c(v.re, v.im));
            for (let it = 0; it < iterMax; it++) { await new Promise(r => setTimeout(r, 0));
const Iload = Array(nb + 1).fill(0).map(() => c(0, 0));
                
                // *** MUDANÇA: Loop ignora o slackBusId atual ***
                for (let b = 1; b <= nb; b++) {
                    if (b === slackBusId) continue;
                    if(connectedBuses.has(b)){ const S_b = S[b];
if (cAbs(V[b]) > 1e-9 && (Math.abs(S_b.re) + Math.abs(S_b.im) > 0)) Iload[b] = cConj(cDiv(S_b, V[b])); else Iload[b] = c(0, 0);
} else Iload[b] = c(0,0); } 
                
                const Iramo = {}; const Idow = Array(nb + 1).fill(0).map(() => c(0, 0));
for (const b of orderBwd) { const curr = cAdd(Iload[b], Idow[b]); const p = parent[b];
if (p > 0 && p <= nb) { Iramo[`${p}-${b}`] = curr; Idow[p] = cAdd(Idow[p], curr);
} } V_ant = V.map(v => c(v.re, v.im)); V[slackBusId] = c(1, 0); for(let b=1; b<=nb; b++) if(!connectedBuses.has(b)) V[b] = c(0,0);
for (const u of orderFwd) { for (const v of adjFilhos[u]) { const r = ramoIdx[`${u}-${v}`];
if (r) { const Ir = Iramo[`${u}-${v}`] || c(0, 0); const Z_val = r.Z || c(0,0);
V[v] = cSub(V[u], cMul(Z_val, Ir)); } } } let maxDv = 0;
for(const b of connectedBuses) maxDv = Math.max(maxDv, cAbs(cSub(V[b], V_ant[b]))); if (maxDv < tol) { conv = true; break;
} }
            
            const resBarras = [];
const substationBuses = getSubstationBuses(); // Pega todas as fontes
            for (let b = 1; b <= nb; b++) { const isC = connectedBuses.has(b); const Vm = isC ?
cAbs(V[b]) : 0; const Va = isC ? angDeg(V[b]) : 0;
                // *** MUDANÇA: Carga é 0 se for QUALQUER fonte ***
                const Pmw = (substationBuses.includes(b) ? 0 : (cargas[b]?.P || 0));
const Qmvar = (substationBuses.includes(b) ? 0 : (cargas[b]?.Q || 0));
                resBarras.push({ barra: b, Vmag: Vm, Vang: Va, Pmw, Qmvar, isConnected: isC });
} const IloadFinal = Array(nb + 1).fill(0).map(() => c(0, 0));
            
            // *** MUDANÇA: Loop ignora o slackBusId atual ***
for (let b = 1; b <= nb; b++) {
                if (b === slackBusId) continue;
                if (connectedBuses.has(b)) { const S_b = S[b];
if (cAbs(V[b]) > 1e-9 && (Math.abs(S_b.re) + Math.abs(S_b.im) > 0)) IloadFinal[b] = cConj(cDiv(S_b, V[b])); else IloadFinal[b] = c(0,0);
} else IloadFinal[b] = c(0,0); }
            
            const IdowFinal = Array(nb + 1).fill(0).map(() => c(0, 0)); const IramoFinal = {};
for (const b of orderBwd) { const curr = cAdd(IloadFinal[b], IdowFinal[b]); const p = parent[b];
if (p > 0 && p <= nb) { IramoFinal[`${p}-${b}`] = curr; IdowFinal[p] = cAdd(IdowFinal[p], curr);
} } const resRamos = []; perdasMWtotal = 0; for (const r of ramos) { const i = IramoFinal[`${r.de}-${r.para}`] ||
c(0, 0); const Vde = connectedBuses.has(r.de) ? V[r.de] : c(0,0); const Sij = cMul(Vde, cConj(i));
const Pmw = Sij.re * Sbase; const Qmvar = Sij.im * Sbase; const Smva = cAbs(Sij) * Sbase;
const Zr = r.Z?.re || 0; const pMW = cAbs(i) * cAbs(i) * Zr * Sbase;
if (isFinite(pMW)) perdasMWtotal += pMW; else console.warn(`runFluxoLocal: Perdas inválida ${r.de}-${r.para}`);
resRamos.push({ idx: r.idx, de: r.de, para: r.para, Pmw, Qmvar, Smva, Smax: r.Smax, perdasMW: isFinite(pMW)? pMW : 0, isNA: r.isNA });
} const finalUnserved = new Set(unservedBusesFromValidation);
            for(let b=1; b<=nb; b++) {
                if(b !== slackBusId && !connectedBuses.has(b) && cargas[b] && (cargas[b].P > 0 || cargas[b].Q > 0)) finalUnserved.add(b);
            }
if (!isFinite(perdasMWtotal)) { console.warn("runFluxoLocal: perdasMWtotal NaN/Inf"); perdasMWtotal = 0; }
            return { resBarras, resRamos, perdasMWtotal, unservedBuses: finalUnserved };
}
        // *** FIM DA CÓPIA LOCAL MODIFICADA ***

        // --- MUDANÇA: btnFluxo (implementa lógica "dividir para conquistar") ---
btnFluxo.addEventListener('click', async () => {
            gaStatus.textContent = 'Calculando MST Base Pós-Falha...'; gaStatus.style.color = 'var(--info)'; btnOtimizar.disabled = true; btnFluxo.disabled = true; gaLogDetail.innerHTML = ''; baseMstLineKeys.clear();
            const linhasMalha = getLinhasFromTable(tblMalha); const linhaFalhaKeys = Array.from(selLinhaFalha.selectedOptions).map(opt => opt.value).filter(val => val !== 'SEM_FALHA'); const linhaFalhaSet = new Set(linhaFalhaKeys); const isSemFalha = linhaFalhaKeys.length === 0 && Array.from(selLinhaFalha.selectedOptions).some(opt => opt.value === 'SEM_FALHA'); const 
nb = getNb(); const reqLines = nb > 1 ? nb - 1 : 0; // Isso não é mais exato
            
            // *** ADIÇÃO: LER FONTES ***
            const substationBuses = getSubstationBuses();
            const reqLinesMin = nb - substationBuses.length; // Mínimo de linhas para conectar tudo
            logGADetail(`Fontes (Subestações): ${substationBuses.join(', ')}`);
            // *** FIM ADIÇÃO ***
            
if (linhaFalhaKeys.length > 0 && Array.from(selLinhaFalha.selectedOptions).some(opt => opt.value === 'SEM_FALHA')) { gaStatus.textContent = 'Erro: "Sistema Normal" não pode ser selecionado com falhas.'; gaStatus.style.color = 'var(--bad)'; btnOtimizar.disabled = false;
btnFluxo.disabled = false; return; }
            // *** MUDANÇA: Checa o novo mínimo de linhas ***
            if (linhasMalha.length < reqLinesMin && nb > 1) { gaStatus.textContent = `Erro: Mínimo ${reqLinesMin} linhas para ${nb} barras com ${substationBuses.length} fontes.`;
gaStatus.style.color = 'var(--bad)'; btnOtimizar.disabled = false; btnFluxo.disabled = false; return;
}
            
            // ... (Validação de seleção de falha [cite: 394-398] idêntica) ...
let candidateLines = linhasMalha.filter(l => isSemFalha || (!linhaFalhaSet.has(`${l.de}-${l.para}`) && !linhaFalhaSet.has(`${l.para}-${l.de}`)));
candidateLines.sort((a, b) => (a.Z || Infinity) - (b.Z || Infinity));
const dsu = new (class DSU { constructor(n){this.parent=Array(n+1).fill(0).map((_,i)=>i);this.numSets=n}find(i){if(this.parent[i]===i)return i;return this.parent[i]=this.find(this.parent[i])}union(i,j){const rI=this.find(i);const rJ=this.find(j);if(rI!==rJ){this.parent[rI]=rJ;this.numSets--;return!0}return!1}})(nb);
            const mstLines = [];
for (const line of candidateLines) { if (line.de>=1 && line.de<=nb && line.para>=1 && line.para<=nb && dsu.union(line.de, line.para)) mstLines.push(line);
// *** MUDANÇA: Não podemos mais parar em N-1 ***
            // if (mstLines.length >= reqLines && dsu.numSets === 1) break; 
            }
            logGADetail(`MST base: ${mstLines.length} chaves. Falha(s): ${isSemFalha ? 'Nenhuma' : linhaFalhaKeys.join(', ')}`);
baseMstLineKeys.clear(); mstLines.forEach(l => baseMstLineKeys.add(`${l.de}-${l.para}`));

            // *** NOVA LÓGICA: CHECAR CONEXÃO DE FONTES ***
            if (isSemFalha && substationBuses.length > 1) {
                const roots = substationBuses.map(b => dsu.find(b));
                const uniqueRoots = new Set(roots);
                if (uniqueRoots.size < roots.length) {
                    gaStatus.textContent = 'Erro MST: Fontes conectadas em modo normal!';
                    gaStatus.style.color = 'var(--bad)';
                    logGADetail('Erro: MST conectou subestações. Verifique linhas de amarração.', 'bad');
                    btnOtimizar.disabled = false; btnFluxo.disabled = false; return;
                }
            }

            // *** NOVA LÓGICA: CHECAR BARRAS REQUERIDAS ***
            const requiredBusesBase = new Set(substationBuses);
for(let b=1; b<=nb; b++) if(!substationBuses.includes(b) && cargas[b] && (cargas[b].P > 0 || cargas[b].Q > 0)) requiredBusesBase.add(b);
            
            const sourceRoots = new Set(substationBuses.map(b => dsu.find(b)));
let allConnectedBase = true; const unservedSetBase = new Set();
for(const reqBus of requiredBusesBase){ 
                // Se a raiz da barra NÃO ESTÁ no Set de raízes das fontes, está isolada
                if(!sourceRoots.has(dsu.find(reqBus))){ 
                    allConnectedBase = false; 
                    if(!substationBuses.includes(reqBus)) unservedSetBase.add(reqBus);
} } 
            
            if(!allConnectedBase){ 
                gaStatus.textContent = `Erro: ${unservedSetBase.size} barras de carga não conectadas (MST Base).`; 
                gaStatus.style.color = 'var(--bad)';
logGADetail(`Não conectadas (base): ${[...unservedSetBase].join(', ')}`, 'bad'); renderResultados([], []); const resBD = [];
for(let b=1; b<=nb; b++){ const isCD = sourceRoots.has(dsu.find(b));
resBD.push({ barra: b, Vmag: (isCD ? 1.0 : 0), Vang: 0, Pmw: (cargas[b]?.P || 0), Qmvar: (cargas[b]?.Q || 0), isConnected: isCD });
} desenharRede(nb, mstLines, resBD); btnOtimizar.disabled = false; btnFluxo.disabled = false; return;
}
            
            // *** NOVA LÓGICA: LOOP DE FLUXO "DIVIDIR PARA CONQUISTAR" ***
            try {
                let allResBarras = new Array(nb + 1);
                let allResRamos = [];
                let totalUnserved = new Set();
                const connectedSet = new Set();
                
                const dsu_fluxo = new DSU(nb);
                mstLines.forEach(l => dsu_fluxo.union(l.de, l.para));

                for (const sourceId of substationBuses) {
                    const root = dsu_fluxo.find(sourceId);
                    // Pega todas as linhas que pertencem à "ilha" desta fonte
                    const minhasLinhas = mstLines.filter(l => dsu_fluxo.find(l.de) === root);
                    
                    if (minhasLinhas.length === 0 && substationBuses.length > 1) {
                        // Esta fonte não está conectada a nada
                         allResBarras[sourceId] = { barra: sourceId, Vmag: 1.0, Vang: 0, Pmw: 0, Qmvar: 0, isConnected: true };
                         connectedSet.add(sourceId);
                         continue;
                    }
                    
                    // Chama o motor de fluxo modificado
                    const { resBarras, resRamos, unservedBuses } = await runFluxoLocal(minhasLinhas, sourceId);
                    
                    // Combina os resultados
                    resBarras.forEach(b => {
                        if (b.isConnected) {
                            allResBarras[b.barra] = b; // Sobrescreve
                            connectedSet.add(b.barra);
                        }
                    });
                    allResRamos.push(...resRamos);
                    unservedBuses.forEach(b => totalUnserved.add(b));
                }

                // Preenche barras que não foram conectadas
                const finalBarras = [];
                for (let b = 1; b <= nb; b++) {
                    if (allResBarras[b]) {
                        finalBarras.push(allResBarras[b]);
                    } else {
                        // Se não foi conectada por nenhum fluxo, está isolada
                        const isC = connectedSet.has(b); // Deve ser falso
                        finalBarras.push({ barra: b, Vmag: 0, Vang: 0, Pmw: (cargas[b]?.P || 0), Qmvar: (cargas[b]?.Q || 0), isConnected: isC });
                    }
                }
                
renderResultados(finalBarras, allResRamos);
desenharRede(getNb(), allResRamos, finalBarras);
                gaStatus.textContent = 'Fluxo base (MST) calculado.'; gaStatus.style.color = 'var(--ok)';
                
                // Checagem final de barras não atendidas
                const finalUnserved = new Set();
                for(let b=1; b<=nb; b++) {
                    if (requiredBusesBase.has(b) && !connectedSet.has(b)) {
                        finalUnserved.add(b);
                    }
                }
                const unservedArray = Array.from(finalUnserved);
if(unservedArray.length > 0) logGADetail(`Barras não atendidas (base): ${unservedArray.join(', ')}`, 'warn');
} catch (error) { gaStatus.textContent = 'Erro fluxo base (MST): ' + error.message; gaStatus.style.color = 'var(--bad)';
logGADetail(`Erro fluxo base: ${error.message}`, 'bad'); alert('Erro fluxo base (MST): ' + error.message); try { const rBE=[];
for(let b=1; b<=nb; b++) rBE.push({barra:b, Vmag:0, Vang:0, Pmw:(cargas[b]?.P||0), Qmvar:(cargas[b]?.Q||0), isConnected:false}); desenharRede(nb, mstLines, rBE);
} catch(drawError){} }
            btnOtimizar.disabled = false; btnFluxo.disabled = false;
});

        // Inicialização
        carregarExemplo10();
// Limpeza de workers ao fechar a página
        window.addEventListener('beforeunload', () => {
            terminateWorkers();
        });
</script>
</body>
</html>
